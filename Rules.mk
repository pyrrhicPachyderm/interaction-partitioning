$(from_root)-clean:
	@(\
		shopt -s globstar &&\
		cd $(from_root) &&\
		$(RM) **/*.o **/*.d **/*.out;\
	)
	@$(RM) $(from_root)/output/*/*
	@for i in $(from_root)/output/*; do if [ -f "$$i" ]; then $(RM) "$$i"; fi; done
.PHONY: $(from_root)-clean

processed_data_files = $(patsubst %,$(from_root)/output/$(1)/%,focal-vector.data response-vector.data design-matrix.data)

tcl_raw_data := $(from_root)/TCL_DrosMCT/Data/d_both.csv

#process_data_template takes the dataset abbreviation and the raw data file(s).
define process_data_template =
$$(call processed_data_files,$(1)) &: $(from_root)/scripts/process-$(1) $(2)
	./$$< $(2) $$(call processed_data_files,$(1))
endef

$(eval $(call process_data_template,tcl,$(tcl_raw_data)))
$(eval $(call process_data_template,test,))
$(eval $(call process_data_template,cxr,))

#output_template takes the dataset abbreviation, output file name, the program file name, and the flags.
define output_template =
$(from_root)/output/$(1)/$(2).data: $(from_root)/src/$(3).out $$(call processed_data_files,$(1))
	./$$< $$(call processed_data_files,$(1)) $$@ -p $(4)
endef

$(eval $(call output_template,tcl,brute,brute,))
$(eval $(call output_template,tcl,rjmcmc-flat,rjmcmc,))
$(eval $(call output_template,tcl,rjmcmc-aic,rjmcmc,-a))
$(eval $(call output_template,test,brute,brute,))

tcl_data_files := $(call processed_data_files,tcl) $(from_root)/data/tcl-species.csv $(from_root)/output/tcl/brute.data
r_source_files := $(patsubst %,$(from_root)/r/%,parameters.R input-data.R post-process.R brute-post-process.R coclassification-table.R grouped-matrix.R mantel-test.R dist-matrix.R)

$(from_root)/output/article-data.rda: $(from_root)/article-analysis $(tcl_data_files) $(r_source_files)
	./$< $@

#Test data analysis.

brutetest: $(from_root)/output/test/brute.data
.PHONY: brutetest

#Submodules
$(from_root)/TCL_DrosMCT/%:
	git -C "$(from_root)" submodule update --init

#Secondary with no targets prevents deletion of intermediate files.
.SECONDARY:

##########################################################################################################
#Stuff for making C/C++ files. Making extensive use of Peter Miller's "Recursive Make Considered Harmful".
##########################################################################################################
#`CC` should be `gcc` or `g++`, and `CEXT` should correspondingly `c` or `cpp`
CC := g++
CEXT := cpp
CFLAGS += -std=c++20 -Wall -Wpedantic -Wextra -Wno-unused-parameter -O3 -I/usr/include/eigen3
CLIBS := -lm

#These two should work for most projects, but keep an eye on them.
CDIRS := $(shell find '$(from_root)' -name '.git' -prune -o -name '*.$(CEXT)' -printf '%h\n' | sort -u) #All directories containing .c/cpp files, not searching .git
CMAINSRC := $(shell grep -lr --exclude-dir='.git' --include='*.$(CEXT)' -E '^(int|void)\s*main' '$(from_root)') #All .c/cpp files with a main function, not searching .git

###############################
#A big ugly pile of make hacks.
#All the stuff that might need editing as the project changes should be above here.
###############################
CFLAGS += $(patsubst %,-I%,$(CDIRS))
#Find all C files
CSRC := $(shell find '$(from_root)' -name '*.$(CEXT)')
#Find all .c/.cpp files except those that lead to excutables (all the ones without mains)
CSUPPSRC := $(shell find '$(from_root)' -name '*.$(CEXT)' $(shell printf '! -name %s ' $(notdir $(CMAINSRC))))
#Determine the object files
COBJ := $(CSRC:.$(CEXT)=.o)
CSUPPOBJ := $(CSUPPSRC:.$(CEXT)=.o)
#Compile the object files
#This can't be done with the built-in implicit rule as we want to use CFLAGS even for C++
$(from_root)/%.o: $(from_root)/%.$(CEXT)
	$(CC) $(CFLAGS) -c $< -o $@
#Link the object files
#Note that this assumes all executables depend on all object files, but I can't think how to fix that nicely.
$(from_root)/%.out: $(from_root)/%.o $(CSUPPOBJ)
	$(CC) $(CFLAGS) $^ -o $@ $(CLIBS)
#Include the autogenerated dependencies files
include $(COBJ:.o=.d)
#Rule to build dependencies files
$(from_root)/%.d: $(from_root)/%.$(CEXT) $(from_root)/depend.sh
	./$(word 2,$^) $(CC) $(from_root) $(shell dirname $<) $(CFLAGS) $< > $@
